<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Incident Tracker — Codebase Concept Map</title>
  <style>
    :root {
      --bg: #0d0d0f;
      --surface: #16161a;
      --surface2: #1e1e24;
      --border: #2a2a35;
      --text: #e2e2e8;
      --muted: #5a5a72;
      --accent: #7c6af7;
      --know: #34d399;
      --fuzzy: #fbbf24;
      --unknown: #f87171;
      --fe: #818cf8;   /* frontend */
      --be: #34d399;   /* backend  */
      --au: #fb923c;   /* auth     */
      --te: #f472b6;   /* testing  */
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
    }

    /* ── Header ─────────────────────────────────── */
    header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 7px 16px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    header h1 { font-size: 13px; font-weight: 600; }
    header p  { font-size: 11px; color: var(--muted); }
    .layer-legend {
      display: flex;
      gap: 10px;
      margin-left: auto;
    }
    .layer-chip {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 10px;
      color: var(--muted);
    }
    .layer-dot { width: 8px; height: 8px; border-radius: 50%; }

    /* ── Canvas wrapper ─────────────────────────── */
    #canvas-wrap {
      flex: 1 1 0;
      position: relative;
      overflow: hidden;
      min-height: 0;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    /* ── Tooltip ────────────────────────────────── */
    #tooltip {
      position: absolute;
      display: none;
      pointer-events: none;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px 12px;
      max-width: 230px;
      z-index: 20;
      box-shadow: 0 8px 24px rgba(0,0,0,.5);
    }
    #tt-title { font-size: 12px; font-weight: 600; margin-bottom: 4px; }
    #tt-desc  { font-size: 11px; color: var(--muted); line-height: 1.5; }
    #tt-path  { font-size: 10px; color: var(--accent); font-family: monospace; margin-top: 5px; }

    /* ── Hint bar ───────────────────────────────── */
    #hint {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(13,13,15,.8);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 4px 14px;
      font-size: 10px;
      color: var(--muted);
      pointer-events: none;
      white-space: nowrap;
    }

    /* ── Bottom panel ───────────────────────────── */
    #bottom {
      display: flex;
      height: 246px;
      flex-shrink: 0;
      border-top: 1px solid var(--border);
    }

    /* ── Sidebar ────────────────────────────────── */
    #sidebar {
      width: 390px;
      flex-shrink: 0;
      background: var(--surface);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .sect {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .sect-title {
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--muted);
      margin-bottom: 7px;
    }

    /* connection type buttons */
    #conn-type { display: flex; flex-wrap: wrap; gap: 4px; }
    button {
      background: var(--surface2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 5px;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      transition: background .12s, border-color .12s;
    }
    button:hover { background: var(--border); }
    button.active { background: var(--accent); border-color: var(--accent); color: #fff; }
    .conn-btn { font-size: 10px; padding: 3px 8px; }

    /* actions row */
    .actions-row { display: flex; gap: 5px; flex-wrap: wrap; }

    /* presets */
    .preset-btn { font-size: 10px; padding: 3px 9px; }

    /* node list */
    #node-list {
      flex: 1;
      overflow-y: auto;
      padding: 4px 12px 8px;
      font-size: 11px;
    }
    #node-list::-webkit-scrollbar { width: 3px; }
    #node-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

    .layer-group-header {
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
      padding: 6px 0 3px;
    }
    .node-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 2px 0;
    }
    .node-row .node-name { flex: 1; cursor: default; }
    .node-row .node-name:hover { color: #fff; }
    .kb-btn {
      font-size: 9px;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      transition: opacity .12s;
      flex-shrink: 0;
    }
    .kb-btn:hover { opacity: .8; }
    .kb-know    { background: #064e3b; color: var(--know); }
    .kb-fuzzy   { background: #451a03; color: var(--fuzzy); }
    .kb-unknown { background: #450a0a; color: var(--unknown); }

    /* ── Prompt panel ───────────────────────────── */
    #prompt-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 14px;
      min-width: 0;
    }
    #prompt-panel .sect-title { margin-bottom: 0; }
    #prompt-out {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 7px;
      padding: 10px 12px;
      font-size: 11.5px;
      line-height: 1.65;
      overflow-y: auto;
      color: var(--text);
      white-space: pre-wrap;
      min-height: 0;
    }
    #prompt-out::-webkit-scrollbar { width: 3px; }
    #prompt-out::-webkit-scrollbar-thumb { background: var(--border); }
    .prompt-footer { display: flex; gap: 6px; flex-shrink: 0; }
    #copy-btn { background: var(--accent); border-color: var(--accent); color: #fff; }
    #copy-btn:hover { background: #6654e0; }
  </style>
</head>
<body>

<header>
  <div>
    <h1>Incident Tracker — Codebase Concept Map</h1>
    <p>Mark what you know · draw connections · copy a targeted learning prompt</p>
  </div>
  <div class="layer-legend">
    <span class="layer-chip"><span class="layer-dot" style="background:var(--fe)"></span>Frontend</span>
    <span class="layer-chip"><span class="layer-dot" style="background:var(--be)"></span>Backend</span>
    <span class="layer-chip"><span class="layer-dot" style="background:var(--au)"></span>Auth</span>
    <span class="layer-chip"><span class="layer-dot" style="background:var(--te)"></span>Testing</span>
  </div>
</header>

<div id="canvas-wrap">
  <canvas id="canvas"></canvas>
  <div id="tooltip">
    <div id="tt-title"></div>
    <div id="tt-desc"></div>
    <div id="tt-path"></div>
  </div>
  <div id="hint">Drag to move nodes &nbsp;·&nbsp; Click a node to start an edge, click another to connect &nbsp;·&nbsp; Right-click edge label to delete</div>
</div>

<div id="bottom">
  <div id="sidebar">

    <div class="sect">
      <div class="sect-title">Connection type</div>
      <div id="conn-type">
        <button class="conn-btn active" data-type="calls">calls</button>
        <button class="conn-btn" data-type="depends on">depends on</button>
        <button class="conn-btn" data-type="contains">contains</button>
        <button class="conn-btn" data-type="subscribes to">subscribes to</button>
        <button class="conn-btn" data-type="reads from">reads from</button>
        <button class="conn-btn" data-type="tests">tests</button>
        <button class="conn-btn" data-type="protects">protects</button>
      </div>
    </div>

    <div class="sect" style="display:flex;gap:16px;align-items:flex-start;">
      <div style="flex:1">
        <div class="sect-title">Actions</div>
        <div class="actions-row">
          <button onclick="autoLayout()">Auto-layout</button>
          <button onclick="clearEdges()">Clear edges</button>
          <button onclick="resetAll()">Reset</button>
        </div>
      </div>
      <div>
        <div class="sect-title">Persona presets</div>
        <div class="actions-row">
          <button class="preset-btn" onclick="applyPreset('frontend')">Frontend dev</button>
          <button class="preset-btn" onclick="applyPreset('backend')">Backend dev</button>
          <button class="preset-btn" onclick="applyPreset('fullstack')">Full-stack</button>
          <button class="preset-btn" onclick="applyPreset('newcomer')">Newcomer</button>
        </div>
      </div>
    </div>

    <div id="node-list"></div>

  </div>

  <div id="prompt-panel">
    <div class="sect-title">Learning prompt — copy into Claude</div>
    <div id="prompt-out"></div>
    <div class="prompt-footer">
      <button id="copy-btn" onclick="copyPrompt()">Copy prompt</button>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════
// DATA
// ═══════════════════════════════════════════════════════════════════

const LAYER_COLORS = {
  frontend: '#818cf8',
  backend:  '#34d399',
  auth:     '#fb923c',
  testing:  '#f472b6',
};

const LAYER_LABELS = {
  frontend: 'Frontend',
  backend:  'Backend',
  auth:     'Auth',
  testing:  'Testing',
};

const NODES_DEF = [
  // Frontend
  { id: 'nextjs',     label: 'Next.js App Router', layer: 'frontend', path: 'app/',                       desc: 'File-based routing, Server Components, layouts, Server Actions. Drives the whole UI shell.' },
  { id: 'dashboard',  label: 'Dashboard',           layer: 'frontend', path: 'app/dashboard/page.tsx',    desc: 'Client component showing active incidents. Create, resolve, and delete actions live here.' },
  { id: 'incidents',  label: 'Incidents Page',      layer: 'frontend', path: 'app/incidents/page.tsx',    desc: 'All-incidents table — active + resolved. Read-only view with status filtering.' },
  { id: 'sidebar',    label: 'Sidebar',             layer: 'frontend', path: 'components/Sidebar.tsx',    desc: 'Client component with nav links and sign-out button. Rendered in the dashboard layout.' },
  { id: 'shadcn',     label: 'shadcn/ui',           layer: 'frontend', path: 'components/ui/',            desc: 'Accessible UI primitives (Button, Input, Badge). Tailwind-based, copy-paste components.' },
  { id: 'utils',      label: 'lib/utils.ts',        layer: 'frontend', path: 'lib/utils.ts',              desc: 'cn() for Tailwind class merging + formatDistanceToNow() for human-readable timestamps.' },

  // Backend
  { id: 'convex',     label: 'Convex',              layer: 'backend',  path: 'convex/',                   desc: 'Cloud real-time DB. Runs in Convex cloud even in dev — mutations and queries go over network.' },
  { id: 'schema',     label: 'schema.ts',           layer: 'backend',  path: 'convex/schema.ts',          desc: 'Defines the incidents table: title, description, severity (P0–P3), status, assignee, resolvedAt. Includes by_status index.' },
  { id: 'crudops',    label: 'incidents.ts',        layer: 'backend',  path: 'convex/incidents.ts',       desc: 'Convex mutations: list (with optional status filter), create, resolve, update, remove.' },
  { id: 'usequery',   label: 'useQuery',            layer: 'backend',  path: '(React hook)',              desc: 'Real-time reactive query — auto-updates via WebSocket when DB changes. No polling needed.' },
  { id: 'usemutation',label: 'useMutation',         layer: 'backend',  path: '(React hook)',              desc: 'Fire-and-forget DB write hook. Returns a callable function. No loading state management needed.' },
  { id: 'ws',         label: 'WebSocket',           layer: 'backend',  path: 'Convex cloud',              desc: 'Convex pushes DB changes to subscribed queries over WebSocket, triggering React re-renders.' },

  // Auth
  { id: 'nextauth',   label: 'NextAuth v5',         layer: 'auth',     path: 'auth.ts',                   desc: 'Auth framework in beta. Credentials provider only — no OAuth. JWT session strategy.' },
  { id: 'authts',     label: 'auth.ts',             layer: 'auth',     path: 'auth.ts',                   desc: 'NextAuth config — checks DEMO_EMAIL/DEMO_PASSWORD env vars, returns static user object on success.' },
  { id: 'middleware',  label: 'middleware.ts',      layer: 'auth',     path: 'middleware.ts',             desc: 'Protects /dashboard and /incidents. Redirects unauthenticated users to /signin.' },
  { id: 'jwt',        label: 'JWT Sessions',        layer: 'auth',     path: 'auth.ts',                   desc: 'Stateless sessions stored in a signed cookie. No DB session table required.' },

  // Testing
  { id: 'playwright', label: 'Playwright E2E',      layer: 'testing',  path: 'tests/e2e/',                desc: 'Browser tests: auth setup runs once, then dashboard.spec.ts and incidents.spec.ts. Hits the real Convex cloud DB.' },
  { id: 'vitest',     label: 'Vitest Unit',         layer: 'testing',  path: 'tests/unit/',               desc: '5 unit tests for formatDistanceToNow using jsdom + vi.useFakeTimers(). Fast, isolated.' },
];

const EDGES_DEF = [
  { from: 'dashboard',  to: 'usequery',    type: 'calls' },
  { from: 'dashboard',  to: 'usemutation', type: 'calls' },
  { from: 'incidents',  to: 'usequery',    type: 'calls' },
  { from: 'usequery',   to: 'convex',      type: 'subscribes to' },
  { from: 'usemutation',to: 'convex',      type: 'calls' },
  { from: 'convex',     to: 'ws',          type: 'sends via' },
  { from: 'ws',         to: 'usequery',    type: 'updates' },
  { from: 'convex',     to: 'crudops',     type: 'executes' },
  { from: 'crudops',    to: 'schema',      type: 'depends on' },
  { from: 'nextjs',     to: 'dashboard',   type: 'contains' },
  { from: 'nextjs',     to: 'incidents',   type: 'contains' },
  { from: 'nextjs',     to: 'sidebar',     type: 'contains' },
  { from: 'dashboard',  to: 'shadcn',      type: 'uses' },
  { from: 'dashboard',  to: 'utils',       type: 'uses' },
  { from: 'nextauth',   to: 'authts',      type: 'configured by' },
  { from: 'authts',     to: 'middleware',  type: 'used by' },
  { from: 'middleware', to: 'nextjs',      type: 'protects' },
  { from: 'nextauth',   to: 'jwt',         type: 'uses' },
  { from: 'playwright', to: 'nextjs',      type: 'tests' },
  { from: 'playwright', to: 'convex',      type: 'reads from' },
  { from: 'vitest',     to: 'utils',       type: 'tests' },
];

const EDGE_COLORS = {
  'calls':           '#818cf8',
  'depends on':      '#34d399',
  'contains':        '#64748b',
  'subscribes to':   '#a78bfa',
  'reads from':      '#22d3ee',
  'tests':           '#f472b6',
  'protects':        '#fb923c',
  'uses':            '#818cf8',
  'sends via':       '#34d399',
  'updates':         '#a78bfa',
  'executes':        '#34d399',
  'configured by':   '#fb923c',
  'used by':         '#fb923c',
};

// ═══════════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════════

let nodes = [];
let edges = [];
let selectedConnType = 'calls';
let connectFrom = null;   // node.id waiting for second click
let dragNode = null;
let dragOffset = { x: 0, y: 0 };
let dragMoved = false;
let hoveredNode = null;
let mousePos = { x: 0, y: 0 };

// ═══════════════════════════════════════════════════════════════════
// CANVAS SETUP
// ═══════════════════════════════════════════════════════════════════

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = 0, H = 0;

function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  W = wrap.clientWidth;
  H = wrap.clientHeight;
  canvas.width  = W * devicePixelRatio;
  canvas.height = H * devicePixelRatio;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.scale(devicePixelRatio, devicePixelRatio);
  draw();
}

// ═══════════════════════════════════════════════════════════════════
// INIT & LAYOUT
// ═══════════════════════════════════════════════════════════════════

function init() {
  nodes = NODES_DEF.map(n => ({ ...n, x: 0, y: 0, knowledge: 'fuzzy' }));
  edges = EDGES_DEF.map(e => ({ ...e }));
  resizeCanvas();
  placeNodes();
  renderNodeList();
  updatePrompt();
  draw();
}

function placeNodes() {
  // Assign rough quadrant centers by layer, then spiral outward
  const centers = {
    frontend: { cx: 0.28, cy: 0.35 },
    backend:  { cx: 0.72, cy: 0.35 },
    auth:     { cx: 0.50, cy: 0.78 },
    testing:  { cx: 0.14, cy: 0.75 },
  };
  const idxByLayer = {};
  const countByLayer = {};
  nodes.forEach(n => { countByLayer[n.layer] = (countByLayer[n.layer] || 0) + 1; });

  nodes.forEach(n => {
    const c = centers[n.layer];
    const count = countByLayer[n.layer];
    const idx   = idxByLayer[n.layer] || 0;
    const r = 70 + count * 10;
    const angle = (idx / count) * Math.PI * 2 - Math.PI / 2;
    n.x = c.cx * W + Math.cos(angle) * r;
    n.y = c.cy * H + Math.sin(angle) * r;
    idxByLayer[n.layer] = idx + 1;
  });
}

// ═══════════════════════════════════════════════════════════════════
// DRAW
// ═══════════════════════════════════════════════════════════════════

const NODE_R = 23;

function drawEdge(e) {
  const a = getNode(e.from), b = getNode(e.to);
  if (!a || !b) return;

  const color = EDGE_COLORS[e.type] || '#555';
  const angle = Math.atan2(b.y - a.y, b.x - a.x);

  // Line
  ctx.beginPath();
  ctx.moveTo(a.x, a.y);
  ctx.lineTo(b.x, b.y);
  ctx.strokeStyle = color + '55';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Arrowhead at target node perimeter
  const ax = b.x - Math.cos(angle) * (NODE_R + 1);
  const ay = b.y - Math.sin(angle) * (NODE_R + 1);
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(ax - 9 * Math.cos(angle - 0.42), ay - 9 * Math.sin(angle - 0.42));
  ctx.lineTo(ax - 9 * Math.cos(angle + 0.42), ay - 9 * Math.sin(angle + 0.42));
  ctx.closePath();
  ctx.fillStyle = color + 'bb';
  ctx.fill();

  // Label at midpoint
  const mx = (a.x + b.x) / 2;
  const my = (a.y + b.y) / 2;
  ctx.font = '9px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const tw = ctx.measureText(e.type).width + 8;
  ctx.fillStyle = 'rgba(13,13,15,.85)';
  ctx.beginPath();
  ctx.roundRect(mx - tw / 2, my - 7, tw, 14, 3);
  ctx.fill();
  ctx.fillStyle = color + 'dd';
  ctx.fillText(e.type, mx, my);
}

function drawNode(n) {
  const kColors = { know: '#34d399', fuzzy: '#fbbf24', unknown: '#f87171' };
  const layerColor = LAYER_COLORS[n.layer];
  const kColor = kColors[n.knowledge];
  const isSource  = connectFrom === n.id;
  const isHovered = hoveredNode === n.id;

  // Connecting-from pulse ring
  if (isSource) {
    ctx.beginPath();
    ctx.arc(n.x, n.y, NODE_R + 8, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff14';
    ctx.fill();
  }

  // Layer ring (outer)
  ctx.beginPath();
  ctx.arc(n.x, n.y, NODE_R + 3, 0, Math.PI * 2);
  ctx.strokeStyle = layerColor + (isHovered ? 'cc' : '44');
  ctx.lineWidth = isHovered ? 2 : 1.5;
  ctx.stroke();

  // Node body
  ctx.beginPath();
  ctx.arc(n.x, n.y, NODE_R, 0, Math.PI * 2);
  ctx.fillStyle = isHovered ? '#23232e' : '#1a1a22';
  ctx.fill();

  // Knowledge ring (inner)
  ctx.beginPath();
  ctx.arc(n.x, n.y, NODE_R, 0, Math.PI * 2);
  ctx.strokeStyle = kColor;
  ctx.lineWidth = 2.5;
  ctx.stroke();

  // Label — wrap long names to 2 lines
  ctx.fillStyle = isHovered ? '#ffffff' : '#d4d4e0';
  ctx.font = `${isHovered ? '600' : '500'} 8.5px system-ui`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const words = n.label.split(' ');
  if (words.length === 1 || n.label.length <= 10) {
    ctx.fillText(n.label.slice(0, 14), n.x, n.y);
  } else {
    const mid = Math.ceil(words.length / 2);
    ctx.fillText(words.slice(0, mid).join(' ').slice(0, 14), n.x, n.y - 5);
    ctx.fillText(words.slice(mid).join(' ').slice(0, 14), n.x, n.y + 6);
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  // Guide line while connecting
  if (connectFrom) {
    const fn = getNode(connectFrom);
    if (fn) {
      ctx.beginPath();
      ctx.moveTo(fn.x, fn.y);
      ctx.lineTo(mousePos.x, mousePos.y);
      ctx.strokeStyle = '#ffffff22';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  edges.forEach(drawEdge);
  nodes.forEach(drawNode);
}

// ═══════════════════════════════════════════════════════════════════
// MOUSE INTERACTION
// ═══════════════════════════════════════════════════════════════════

function getPos(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function hitNode(pos) {
  return nodes.find(n => {
    const dx = n.x - pos.x, dy = n.y - pos.y;
    return dx * dx + dy * dy < (NODE_R + 6) * (NODE_R + 6);
  });
}

function hitEdgeMidpoint(pos) {
  return edges.findIndex(e => {
    const a = getNode(e.from), b = getNode(e.to);
    if (!a || !b) return false;
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const dx = pos.x - mx, dy = pos.y - my;
    return dx * dx + dy * dy < 12 * 12;
  });
}

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  const pos = getPos(e);
  const hit = hitNode(pos);
  dragMoved = false;

  if (hit) {
    dragNode   = hit;
    dragOffset = { x: hit.x - pos.x, y: hit.y - pos.y };
  }
});

canvas.addEventListener('mousemove', e => {
  const pos = getPos(e);
  mousePos = pos;

  if (dragNode) {
    const dx = pos.x + dragOffset.x - dragNode.x;
    const dy = pos.y + dragOffset.y - dragNode.y;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
    dragNode.x = pos.x + dragOffset.x;
    dragNode.y = pos.y + dragOffset.y;
    draw();
    return;
  }

  const hit = hitNode(pos);
  const prev = hoveredNode;
  hoveredNode = hit ? hit.id : null;

  // Tooltip
  const tt = document.getElementById('tooltip');
  if (hit) {
    document.getElementById('tt-title').textContent = hit.label;
    document.getElementById('tt-desc').textContent  = hit.desc;
    document.getElementById('tt-path').textContent  = hit.path;
    tt.style.display = 'block';
    const tx = pos.x + 18, ty = pos.y - 10;
    tt.style.left = Math.min(tx, W - 250) + 'px';
    tt.style.top  = Math.max(ty, 4) + 'px';
    canvas.style.cursor = connectFrom ? 'crosshair' : 'grab';
  } else {
    tt.style.display = 'none';
    canvas.style.cursor = connectFrom ? 'crosshair' : 'default';
  }

  if (prev !== hoveredNode || connectFrom) draw();
});

canvas.addEventListener('mouseup', e => {
  const pos = getPos(e);

  if (dragNode && !dragMoved) {
    // It was a click (no movement) — handle edge drawing
    const hit = dragNode;
    if (connectFrom) {
      if (connectFrom !== hit.id) {
        const dup = edges.find(ed => ed.from === connectFrom && ed.to === hit.id);
        if (!dup) edges.push({ from: connectFrom, to: hit.id, type: selectedConnType });
        updatePrompt();
      }
      connectFrom = null;
    } else {
      connectFrom = hit.id;
    }
    draw();
  } else if (dragNode) {
    // Dragged — just drop
  } else if (!hitNode(pos)) {
    // Clicked empty space
    connectFrom = null;
    draw();
  }

  dragNode = null;
  canvas.style.cursor = 'default';
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  const pos = getPos(e);
  const idx = hitEdgeMidpoint(pos);
  if (idx >= 0) {
    edges.splice(idx, 1);
    updatePrompt();
    draw();
  }
});

// ═══════════════════════════════════════════════════════════════════
// SIDEBAR — connection type
// ═══════════════════════════════════════════════════════════════════

document.querySelectorAll('.conn-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.conn-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    selectedConnType = btn.dataset.type;
  });
});

// ═══════════════════════════════════════════════════════════════════
// SIDEBAR — node list
// ═══════════════════════════════════════════════════════════════════

function renderNodeList() {
  const list = document.getElementById('node-list');
  list.innerHTML = '';

  const kLabels = { know: 'Know', fuzzy: 'Fuzzy', unknown: '?' };
  const kClasses = { know: 'kb-know', fuzzy: 'kb-fuzzy', unknown: 'kb-unknown' };
  const layerOrder = ['frontend', 'backend', 'auth', 'testing'];

  layerOrder.forEach(layer => {
    const layerNodes = nodes.filter(n => n.layer === layer);
    if (!layerNodes.length) return;

    const header = document.createElement('div');
    header.className = 'layer-group-header';
    header.style.color = LAYER_COLORS[layer];
    header.textContent = LAYER_LABELS[layer];
    list.appendChild(header);

    layerNodes.forEach(n => {
      const row = document.createElement('div');
      row.className = 'node-row';
      row.innerHTML = `
        <span class="node-name">${n.label}</span>
        <button class="kb-btn ${kClasses[n.knowledge]}" data-id="${n.id}">
          ${kLabels[n.knowledge]}
        </button>
      `;

      // Cycle knowledge on button click
      row.querySelector('.kb-btn').addEventListener('click', () => {
        const cycle = ['know', 'fuzzy', 'unknown'];
        n.knowledge = cycle[(cycle.indexOf(n.knowledge) + 1) % 3];
        renderNodeList();
        draw();
        updatePrompt();
      });

      // Highlight on canvas when hovering the list row
      row.addEventListener('mouseenter', () => { hoveredNode = n.id; draw(); });
      row.addEventListener('mouseleave', () => { hoveredNode = null; draw(); });

      list.appendChild(row);
    });
  });
}

// ═══════════════════════════════════════════════════════════════════
// PROMPT GENERATION
// ═══════════════════════════════════════════════════════════════════

function updatePrompt() {
  const knows    = nodes.filter(n => n.knowledge === 'know').map(n => n.label);
  const fuzzys   = nodes.filter(n => n.knowledge === 'fuzzy').map(n => n.label);
  const unknowns = nodes.filter(n => n.knowledge === 'unknown').map(n => n.label);
  const gaps     = [...fuzzys, ...unknowns];

  const edgeLines = edges.map(e => {
    const a = getNode(e.from), b = getNode(e.to);
    return a && b ? `• ${a.label} ${e.type} ${b.label}` : null;
  }).filter(Boolean);

  let text = "I'm learning the Incident Tracker codebase (Next.js 15 + Convex + NextAuth v5).\n\n";

  if (knows.length)
    text += `I already understand: ${knows.join(', ')}.\n\n`;

  if (fuzzys.length)
    text += `I'm fuzzy on: ${fuzzys.join(', ')}.\n\n`;

  if (unknowns.length)
    text += `I have no idea about: ${unknowns.join(', ')}.\n\n`;

  if (edgeLines.length && gaps.length) {
    text += `Relationships I want to understand:\n${edgeLines.slice(0, 12).join('\n')}\n\n`;
    text += `Please explain the fuzzy and unknown concepts, focusing on these relationships. `;
    text += `Build on what I already know. Reference concrete file paths from the project `;
    text += `(e.g. convex/incidents.ts, app/dashboard/page.tsx, middleware.ts).`;
  } else if (gaps.length) {
    text += `Please explain these concepts in the context of this codebase. `;
    text += `Reference concrete file paths and build on what I already understand.`;
  } else if (knows.length === nodes.length) {
    text += `Looks like you know the whole stack — nice! `;
    text += `Ask me about a specific area to go deeper.`;
  } else {
    text += `Mark concepts as Know / Fuzzy / Unknown using the sidebar to generate a targeted learning prompt.`;
  }

  document.getElementById('prompt-out').textContent = text;
}

// ═══════════════════════════════════════════════════════════════════
// ACTIONS
// ═══════════════════════════════════════════════════════════════════

function autoLayout() {
  for (let iter = 0; iter < 200; iter++) {
    // Repulsion between all node pairs
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i], b = nodes[j];
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
        const force = 4000 / (dist * dist) * 0.3;
        const fx = (dx / dist) * force, fy = (dy / dist) * force;
        a.x -= fx; a.y -= fy;
        b.x += fx; b.y += fy;
      }
    }
    // Spring attraction along edges
    edges.forEach(e => {
      const a = getNode(e.from), b = getNode(e.to);
      if (!a || !b) return;
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
      const spring = (dist - 130) * 0.018 * 0.3;
      const fx = (dx / dist) * spring, fy = (dy / dist) * spring;
      a.x += fx; a.y += fy;
      b.x -= fx; b.y -= fy;
    });
    // Gentle gravity toward center
    const cx = nodes.reduce((s, n) => s + n.x, 0) / nodes.length;
    const cy = nodes.reduce((s, n) => s + n.y, 0) / nodes.length;
    nodes.forEach(n => {
      n.x += (W / 2 - cx) * 0.012;
      n.y += (H / 2 - cy) * 0.012;
      n.x = Math.max(36, Math.min(W - 36, n.x));
      n.y = Math.max(36, Math.min(H - 36, n.y));
    });
  }
  draw();
}

function clearEdges() {
  edges = [];
  updatePrompt();
  draw();
}

function resetAll() {
  nodes = NODES_DEF.map(n => ({ ...n, x: 0, y: 0, knowledge: 'fuzzy' }));
  edges = EDGES_DEF.map(e => ({ ...e }));
  connectFrom = null;
  placeNodes();
  renderNodeList();
  updatePrompt();
  draw();
}

function applyPreset(name) {
  const maps = {
    frontend: {
      nextjs: 'know', dashboard: 'know', incidents: 'know', sidebar: 'know',
      shadcn: 'know', utils: 'know',
      convex: 'fuzzy', schema: 'unknown', crudops: 'unknown', usequery: 'fuzzy',
      usemutation: 'fuzzy', ws: 'unknown',
      nextauth: 'fuzzy', authts: 'fuzzy', middleware: 'fuzzy', jwt: 'fuzzy',
      playwright: 'fuzzy', vitest: 'know',
    },
    backend: {
      nextjs: 'fuzzy', dashboard: 'unknown', incidents: 'unknown', sidebar: 'unknown',
      shadcn: 'unknown', utils: 'fuzzy',
      convex: 'know', schema: 'know', crudops: 'know', usequery: 'fuzzy',
      usemutation: 'fuzzy', ws: 'know',
      nextauth: 'fuzzy', authts: 'fuzzy', middleware: 'fuzzy', jwt: 'know',
      playwright: 'fuzzy', vitest: 'fuzzy',
    },
    fullstack: {
      nextjs: 'know', dashboard: 'fuzzy', incidents: 'fuzzy', sidebar: 'know',
      shadcn: 'know', utils: 'know',
      convex: 'fuzzy', schema: 'fuzzy', crudops: 'fuzzy', usequery: 'fuzzy',
      usemutation: 'fuzzy', ws: 'unknown',
      nextauth: 'fuzzy', authts: 'fuzzy', middleware: 'fuzzy', jwt: 'fuzzy',
      playwright: 'fuzzy', vitest: 'know',
    },
    newcomer: {
      nextjs: 'fuzzy', dashboard: 'unknown', incidents: 'unknown', sidebar: 'unknown',
      shadcn: 'fuzzy', utils: 'know',
      convex: 'unknown', schema: 'unknown', crudops: 'unknown', usequery: 'unknown',
      usemutation: 'unknown', ws: 'unknown',
      nextauth: 'unknown', authts: 'unknown', middleware: 'unknown', jwt: 'fuzzy',
      playwright: 'unknown', vitest: 'fuzzy',
    },
  };

  const km = maps[name];
  if (!km) return;
  nodes.forEach(n => { if (km[n.id]) n.knowledge = km[n.id]; });
  renderNodeList();
  draw();
  updatePrompt();
}

// ═══════════════════════════════════════════════════════════════════
// COPY
// ═══════════════════════════════════════════════════════════════════

function copyPrompt() {
  const text = document.getElementById('prompt-out').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('copy-btn');
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = orig; }, 1600);
  });
}

// ═══════════════════════════════════════════════════════════════════
// RESIZE
// ═══════════════════════════════════════════════════════════════════

window.addEventListener('resize', () => {
  const prevW = W, prevH = H;
  resizeCanvas();
  if (prevW && prevH) {
    nodes.forEach(n => {
      n.x = (n.x / prevW) * W;
      n.y = (n.y / prevH) * H;
    });
  }
  draw();
});

// ═══════════════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════════════

function getNode(id) { return nodes.find(n => n.id === id); }

// ═══════════════════════════════════════════════════════════════════
// GO
// ═══════════════════════════════════════════════════════════════════

init();
</script>
</body>
</html>
